# 0820 과제.

# 마크다운 뷰어가 없다면 이 링크를 통해 확인해주세요.


https://github.com/MEGA-MK05/practice-


## 목표

1. 수업 시간에 만든 32bit cpu 내부 ram과 register file의 상호 작용을 분석한다 

2. 이전까지 고려하지 못했던 기계어로 변하는 과정 ( 전처리 -> 컴파일 -> 어셈블-> 링킹 )을 이해하여,  
버블 정렬 알고리듬의 동작을 메모리 영역에서는 어떻게 이루어지는지 이해하고 서술한다.   



## 기존 C 코드
```c
void sort(int *pData, int size);
void swap(int *pA, int *pB);

int main()
{
    int arData[6] = {5,4,3,2,1};
    sort(arData,5);
    return 0;
}

void sort(int *pData, int size)
{
    for(int i = 0; i < size; i++){
        for(int j = 0; j < size-i-1; j++){
            if(pData[j] > pData[j+1])
                swap(&pData[j], &pData[j+1]);
        }
    }
}

void swap(int *pA, int *pB)
{
    int temp;
    temp = *pA;
    *pA = *pB;
    *pB = temp;
}
``` 
  
   
해당 코드는 버블 알고리즘을 c로 구현하였습니다.   
앞에 index부터 전부 비교하여, 다음에 있는 값보다 크다면 swap하여 최종적으로 순차 정렬을 하게 만듭니다.  
함수를 호출하고 또 호출하는 과정 속에서 기존에 동작으로 돌아가기 위한 ra값을 저장하거나 하는 로직이 필요하고,  
그리고 동작되는 logic에 비해 많은 stack 크기를 잡아먹는다는 생각이 우선적으로 들었습니다.  



# 시작하기 앞서 고려사항

교수님이 초기에 설정한 stack 크기 0x40=64를 염두해두고 코드를 분석하지만,   
주어진 코드를 바꾸지 않고 해결할 수 없는 상황이었습니다.    
때문에 스택 오버버플로우를 해결하기 위한 방안을 분기로 두어 레포트를 작성하였습니다. 



# 어셈블리어 분석

해당 코드를 asm 변환 사이트를 이용해 RISC-V 명령어셋의 어셈블리 코드로 변환하였습니다.  
이제 이를 단계별로 살펴보며 동작 과정을 확인하겠습니다.



### 1. 초기 상태
```assembly
li     sp, 0x40    # 스택 포인터를 0x40(64번 주소)로 설정
```

**스택 상태:**
```
메모리 주소: [높음]
                   ...
                   68
                   64 ← sp (스택 포인터)
                   60
                   [낮음]
```



### 2. main 함수 호출 
```assembly
addi    sp,sp,-48    # sp = 64 - 48 = 16
sw      ra,44(sp)    # Memory[60] = ra
sw      s0,40(sp)    # Memory[56] = s0
addi    s0,sp,48     # s0 = 16 + 48 = 64
```



**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (main 프레임 포인터)
                   60 ← ra (main 반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 
                   40 ← 
                   36 ← 
                   32 ← 
                   28 ← 
                   24 ← 
                   20 ← 
                   16 ← sp (스택 포인터)
                   [낮음]
```

해당 코드는 2가지 동작을 위해 존재합니다.

1. 함수 호출 시 반환 주소(ra)와 이전 프레임 포인터(s0)를 스택에 백업하여 함수 종료 후 원래 상태로 복원할 수 있도록 하기.
2. 새로운 프레임 포인터(s0)를 설정하여 함수 내에서 지역 변수에 안전하게 접근할 수 있도록 하기.



### 3. main 함수에서 배열 초기화 및 값 할당
```assembly
# 배열 초기화: [0, 0, 0, 0, 0, 0]
# 값 할당: [5, 4, 3, 2, 1, 0]
```

```assembly
        sw      zero,-40(s0) # arr[0] = 0 (배열 초기화)
        sw      zero,-36(s0) # arr[1] = 0 
        sw      zero,-32(s0) # arr[2] = 0 
        sw      zero,-28(s0) # arr[3] = 0
        sw      zero,-24(s0) # arr[4] = 0
        sw      zero,-20(s0) # arr[5] = 0
        li      a5,5         # a5 = 5
        sw      a5,-40(s0)   # arr[0] = a5
        li      a5,4         # a5 = 4  
        sw      a5,-36(s0)   # arr[1] = a5
        li      a5,3         # a5 = 3
        sw      a5,-32(s0)   # arr[2] = a5
        li      a5,2         # a5 = 2
        sw      a5,-28(s0)   # arr[3] = a5
        li      a5,1         # a5 = 1
        sw      a5,-24(s0)   # arr[4] = a5
        
```

**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (main 프레임 포인터)
                   60 ← ra (main 반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 0 (arr[5]) 
                   40 ← 1 (arr[4])
                   36 ← 2 (arr[3])
                   32 ← 3 (arr[2])
                   28 ← 4 (arr[1])
                   24 ← 5 (arr[0])
                   20 ← 
                   16 ← sp (스택 포인터)
                   [낮음]
```

main 프레임 포인터를 기준으로 배열을 할당합니다.
우선 0으로 초기화를 시켜준 다음에, 코드 구성대로 5,4,3,2,1을 arr[0]부터 가득 채우게 됩니다. 



### 4. sort 함수 호출 (main에서)
```assembly
addi    a5,s0,-40    # a5 = 24 (배열 시작 주소)
li      a1,5         # a1 = 5 (배열 크기)
mv      a0,a5        # a0 = 24 (배열 포인터)
call    sort(int*, int)  # sort 함수 호출
```

**레지스터 상태:**
- `a0` = 24 (배열 포인터)
- `a1` = 5 (배열 크기)
- `ra` = main 함수의 다음 명령어 주소



### 5. sort 함수 
```assembly
addi    sp,sp,-48    # sp = 16 - 48 = -32
sw      ra,44(sp)    # Memory[-32+44] = Memory[12] = ra
sw      s0,40(sp)    # Memory[-32+40] = Memory[8] = s0
addi    s0,sp,48     # s0 = -32 + 48 = 16
sw      a0,-36(s0)   # Memory[16-36] = Memory[-20] = 24 (배열 포인터)
sw      a1,-40(s0)   # Memory[16-40] = Memory[-24] = 5 (배열 크기)
```



**스택 상태:**
```
메모리 주소: [높음]
                   64 ← main s0 (main 프레임 포인터)
                   60 ← ra (main 반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 0 (arr[5])
                   40 ← 1 (arr[4])
                   36 ← 2 (arr[3])
                   32 ← 3 (arr[2])
                   28 ← 4 (arr[1])
                   24 ← 5 (arr[0])
                   20 ← 
                   16 ← sort s0 (sort 프레임 포인터)
                   12 ← ra (sort 반환 주소)
                   8  ← main s0 (sort에서 저장한 main s0)
                   4  ← 
                   0  ← 
                   -4 ← 
                   -8 ← 
                   -12 ← 
                   -16 ← 
                   -20 ← 24 (배열 포인터)
                   -24 ← 5 (배열 크기)
                   -28 ← 
                   -32 ← sp (스택 포인터)
                   [낮음]
```

# 문제점   
  
    
교수님께서 작성한 코드 logic 대로 흘러가게 되면 이곳에서 두가지 선택지로 나뉘게 됩니다.
  
  
1. 초기 sp를 넓게 잡아서 충분한 영역을 확보해준다.  
   
2. 코드의 로직에 맞춰서 효율적인 동작을 할 수 있도록 c를 수정해준다.
  
  
asm 코드를 분석하면서 stack 영역에서 일어나는 의존성에 의한 stack overflow를 직접적으로 경험했다.
  
  
효율적인 메모리 사용을 하기 위해 어떻게 코드를 만들어야될까 고민하여 함수 호출을 최소화 하고,
   
   
최대한 제안된 stack 메모리 내에서 작동하게 만들었습니다.

  




## 개선된 C 코드
```c
int main()
{
    int arData[6] = {5,4,3,2,1};
    
    int *pData = arData;
    int size = 5;
    
    for(int i = 0; i < size; i++) {
        for(int j = 0; j < size-i-1; j++) {
            if(pData[j] > pData[j+1]) {
                // swap 로직이 내부 처리리
                int temp = pData[j];
                pData[j] = pData[j+1];
                pData[j+1] = temp;
            }
        }
    }
    
    return 0;
}
```


## 어셈블리어 코드 분석

### 1. 함수 프롤로그
```assembly
addi    sp,sp,-64    # 스택 64바이트 확보
sw      ra,60(sp)    # 반환 주소 저장
sw      s0,56(sp)    # 이전 프레임 포인터 저장
addi    s0,sp,64     # 새 프레임 포인터 설정
```

**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 
                   40 ← 
                   36 ← 
                   32 ← 
                   28 ← 
                   24 ← 
                   20 ← 
                   16 ← 
                   12 ← 
                   8  ← 
                   4  ← 
                   0  ← sp (스택 포인터)
                   [낮음]
```

### 2. 배열 초기화
```assembly
sw      zero,-60(s0)  # arr[0] = 0
sw      zero,-56(s0)  # arr[1] = 0
sw      zero,-52(s0)  # arr[2] = 0
sw      zero,-48(s0)  # arr[3] = 0
sw      zero,-44(s0)  # arr[4] = 0
sw      zero,-40(s0)  # arr[5] = 0
```

**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 
                   40 ← 
                   36 ← 
                   32 ← 
                   28 ← 
                   24 ← 0 (arr[5])
                   20 ← 0 (arr[4])
                   16 ← 0 (arr[3])
                   12 ← 0 (arr[2])
                   8  ← 0 (arr[1])
                   4  ← 0 (arr[0])
                   0  ← sp (스택 포인터)
                   [낮음]
```

### 3. 배열에 값 할당
```assembly
li      a5,5
sw      a5,-60(s0)   # arr[0] = 5
li      a5,4         
sw      a5,-56(s0)   # arr[1] = 4
li      a5,3
sw      a5,-52(s0)   # arr[2] = 3
li      a5,2
sw      a5,-48(s0)   # arr[3] = 2
li      a5,1
sw      a5,-44(s0)   # arr[4] = 1
```

**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← 
                   40 ← 
                   36 ← 
                   32 ← 
                   28 ← 
                   24 ← 0 (arr[5])
                   20 ← 1 (arr[4])
                   16 ← 2 (arr[3])
                   12 ← 3 (arr[2])
                   8  ← 4 (arr[1])
                   4  ← 5 (arr[0])
                   0  ← sp (스택 포인터)
                   [낮음]
```


### 4. 정렬 준비
```assembly
addi    a5,s0,-60    # a5 = 배열 시작 주소 (4)
sw      a5,-28(s0)   # pData = 배열 포인터 저장
li      a5,5
sw      a5,-32(s0)   # size = 5 저장
sw      zero,-20(s0) # i = 0 초기화
```


**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← i = 0 
                   40 ← 
                   36 ← pData (배열 포인터)
                   32 ← size (5)
                   28 ← 
                   24 ← 0 (arr[5])
                   20 ← 1 (arr[4])
                   16 ← 2 (arr[3])
                   12 ← 3 (arr[2])
                   8  ← 4 (arr[1])
                   4  ← 5 (arr[0])
                   0  ← sp (스택 포인터)
                   [낮음]
```

### 5. 버블 정렬 루프

#### 외부 루프 (.L2, .L6)

```assembly
.L2:
        lw      a4,-20(s0) # i값 
        lw      a5,-32(s0) # size(5)
        blt     a4,a5,.L6  # for 문 조건이 만족하면 .L6으로 분기
        li      a5,0       # 외부 for가 끝나면 a5 = 0
        mv      a0,a5      # a0 =a5 => a0 = 0
        lw      ra,60(sp)  # retrun adress 값을 Reg에 불러옴
        lw      s0,56(sp)  # 이전 s0값을 Reg에 불러옴
        addi    sp,sp,64   # 스택포인터를 다시 원래 자리로 되돌림
        jr      ra         # return adress로 돌아감
```

```assembly
.L6:
        sw      zero,-24(s0) # j값 0으로 설정
        j       .L3         
```

```assembly
.L3:
        lw      a4,-32(s0) # size (5) 가져온다.
        lw      a5,-20(s0) # a5 = i
        sub     a5,a4,a5   # size - i
        addi    a5,a5,-1   # size - i - 1 (이중 for문의 중단 조건)
        lw      a4,-24(s0) # a4 = j
        blt     a4,a5,.L5  # j와 중단 조건 비교 (만족되면 L5)
        lw      a5,-20(s0) # a5 = i
        addi    a5,a5,1    # a5 = i + 1
        sw      a5,-20(s0) # i 값 업데이트 
```
# 주의
코드의 흐름에 따라 설명하기 위해 flow대로 나열하였지만,
L3의 조건 분기에 해당하지 않고 끝까지 흐르면 다음단에 L2로 흘러가게 순서로 나열되어있습니다.

**스택 상태:**
```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← i 
                   40 ← j 
                   36 ← pData (배열 포인터)
                   32 ← size (5)
                   28 ← 
                   24 ← 0 (arr[5])
                   20 ← 1 (arr[4])
                   16 ← 2 (arr[3])
                   12 ← 3 (arr[2])
                   8  ← 4 (arr[1])
                   4  ← 5 (arr[0])
                   0  ← sp (스택 포인터)
                   [낮음]
```


#### 내부 루프 (.L3, .L5)
```assembly
.L3:    # 내부 루프 조건 체크
.L5:    # 배열 비교 및 교환
        # pData[j]와 pData[j+1] 비교
        # swap 로직이 인라인화되어 있음
```



#### 인라인화된 swap 로직
```assembly
# if(pData[j] > pData[j+1])
.L5:
lw      a5,-24(s0)  # a5 = j
slli    a5,a5,2     # a5 = j * 4 (인덱스를 바이트 주소로 변환)
lw      a4,-28(s0)  # a4 = pData (배열 시작 주소)
add     a5,a4,a5    # a5 = pData + j*4 (arr[j]의 주소)
lw      a4,0(a5)    # a4 = pData[j] (arr[j]의 값)
lw      a5,-24(s0)  # a5 = j
addi    a5,a5,1     # a5 = j + 1
slli    a5,a5,2     # a5 = (j+1) * 4 (인덱스를 바이트 주소로 변환)
lw      a3,-28(s0)  # a3 = pData (배열 시작 주소)
add     a5,a3,a5    # a5 = pData + (j+1)*4 (arr[j+1]의 주소)
lw      a5,0(a5)    # a5 = pData[j+1] (arr[j+1]의 값)
ble     a4,a5,.L4   # if pData[j] <= pData[j+1], .L4로 점프 (교환 안함)

# temp = pData[j]
lw      a5,-24(s0)    # j 로드
slli    a5,a5,2       # j * 4
lw      a4,-28(s0)    # pData 로드
add     a5,a4,a5      # pData + j*4
lw      a5,0(a5)      # pData[j] 로드
sw      a5,-36(s0)    # temp에 저장

# pData[j] = pData[j+1]
lw      a5,-24(s0)    # j 로드
addi    a5,a5,1       # j+1
slli    a5,a5,2       # (j+1) * 4
lw      a4,-28(s0)    # pData 로드
add     a4,a4,a5      # pData + (j+1)*4
lw      a5,-24(s0)    # j 로드
slli    a5,a5,2       # j * 4
lw      a3,-28(s0)    # pData 로드
add     a5,a3,a5      # pData + j*4
lw      a4,0(a4)      # pData[j+1] 로드
sw      a4,0(a5)      # pData[j] = pData[j+1]

# pData[j+1] = temp
lw      a5,-24(s0)    # j 로드
addi    a5,a5,1        # j+1
slli    a5,a5,2        # (j+1) * 4
lw      a4,-28(s0)    # pData 로드
add     a5,a4,a5      # pData + (j+1)*4
lw      a4,-36(s0)    # temp 로드
sw      a4,0(a5)      # pData[j+1] = temp
```

```
.L4:
        lw      a5,-24(s0)    # a5 = j (현재 j 값 로드)
        addi    a5,a5,1       # a5 = j + 1 (j 증가)
        sw      a5,-24(s0)    # j = j + 1 (증가된 j 값 저장)

```


## 최종 스택 레이아웃

```
메모리 주소: [높음]
                   64 ← s0 (프레임 포인터)
                   60 ← ra (반환 주소)
                   56 ← 이전 s0 값
                   52 ← 
                   48 ← 
                   44 ← i 
                   40 ← j 
                   36 ← pData (배열 포인터)
                   32 ← size (5)
                   28 ← temp
                   24 ← 5 (arr[5])
                   20 ← 4 (arr[4])
                   16 ← 3 (arr[3])
                   12 ← 2 (arr[2])
                   8  ← 1 (arr[1])
                   4  ← 0 (arr[0])
                   0  ← sp (스택 포인터)
                   [낮음]
```


## 인라인화의 효과

### 1. 함수 호출 오버헤드 제거
- `call' 등 명령어 제거
- 레지스터 백업/복원 제거
- 스택 프레임 생성/해제 제거

### 2. 메모리 사용량
- **기존**: 48바이트 × 3함수 = 144바이트
- **인라인화**: 64바이트 × 1함수 = 64바이트
- **감소율**: 56% 감소



## 결론

인라인화를 통해 함수 호출 오버헤드를 제거하고 전체적인 메모리 사용량을 줄였습니다. 하지만 개별 함수의 스택 크기는 증가했으며,  
이는 모든 변수를 하나의 스택 프레임에서 관리하기 때문입니다. 전반적으로 성능과 메모리 효율성이 향상되었습니다.
베릴로그에서 면적과 타이밍의 trade off 를 목적으로 같은 모듈을 재사용한다거나 하는 여러가지 기술이 있었는데,
가독성을 포기하고 stack 영역에서의 직접 효율적으로 제어하는 이러한 C 작성 기술을 배울 수 있었습니다.
지금은 비교적 간단한 버블 정렬이기때문에, 스택의 depth가 깊어지는 (의존성 함수)의 inline이 가독성을 많이 해치지 않았지만,
더 긴 코드, 그리고 유지 보수를 요구하는 코드에서는 inline 행위 자체가 코드의 기능 자체를 저해할 수 있기 떄문에  
메모리 영역에서의 stack 여유 공간을 근거로 코딩을 조율할 수 있는 스킬이 중요하다는 것을 꺠달았습니다.